import { describe, it, expect } from 'vitest';
import { parseGeneticDataString } from './geneticDataParser';

describe('parseGeneticDataString', () => {
  describe('23andMe format', () => {
    it('should parse 23andMe format correctly', () => {
      const content = `# This is a 23andMe file
# rsid chromosome position genotype
rs4880 6 160098096 CC
rs1050450 11 89011046 CT
rs713041 5 132285597 GG`;

      const result = parseGeneticDataString(content);

      expect(result.data['RS4880']).toEqual({ allele1: 'C', allele2: 'C' });
      expect(result.data['RS1050450']).toEqual({ allele1: 'C', allele2: 'T' });
      expect(result.data['RS713041']).toEqual({ allele1: 'G', allele2: 'G' });
    });

    it('should handle tab-separated 23andMe format', () => {
      const content = `# rsid\tchromosome\tposition\tgenotype
rs4880\t6\t160098096\tCC
rs1050450\t11\t89011046\tCT`;

      const result = parseGeneticDataString(content);

      expect(result.data['RS4880']).toEqual({ allele1: 'C', allele2: 'C' });
      expect(result.data['RS1050450']).toEqual({ allele1: 'C', allele2: 'T' });
    });

    it('should skip comment lines', () => {
      const content = `# This is a comment
# Another comment
# rsid chromosome position genotype
rs4880 6 160098096 CC`;

      const result = parseGeneticDataString(content);

      expect(Object.keys(result.data)).toHaveLength(1);
      expect(result.data['RS4880']).toEqual({ allele1: 'C', allele2: 'C' });
    });

    it('should handle missing genotype data', () => {
      const content = `# rsid chromosome position genotype
rs4880 6 160098096 --
rs1050450 11 89011046 CT`;

      const result = parseGeneticDataString(content);

      expect(result.data['RS4880']).toEqual({ allele1: '-', allele2: '-' });
      expect(result.data['RS1050450']).toEqual({ allele1: 'C', allele2: 'T' });
    });
  });

  describe('Ancestry format', () => {
    it('should parse Ancestry DNA format correctly', () => {
      const content = `#rsid chromosome position allele1 allele2
rs4880 6 160098096 C C
rs1050450 11 89011046 C T
rs713041 5 132285597 G G`;

      const result = parseGeneticDataString(content);

      expect(result.data['RS4880']).toEqual({ allele1: 'C', allele2: 'C' });
      expect(result.data['RS1050450']).toEqual({ allele1: 'C', allele2: 'T' });
      expect(result.data['RS713041']).toEqual({ allele1: 'G', allele2: 'G' });
    });

    it('should handle tab-separated Ancestry format', () => {
      const content = `#rsid\tchromosome\tposition\tallele1\tallele2
rs4880\t6\t160098096\tC\tC
rs1050450\t11\t89011046\tC\tT`;

      const result = parseGeneticDataString(content);

      expect(result.data['RS4880']).toEqual({ allele1: 'C', allele2: 'C' });
      expect(result.data['RS1050450']).toEqual({ allele1: 'C', allele2: 'T' });
    });

    it('should handle missing allele data with zeros', () => {
      const content = `#rsid chromosome position allele1 allele2
rs4880 6 160098096 0 0
rs1050450 11 89011046 C T`;

      const result = parseGeneticDataString(content);

      expect(result.data['RS4880']).toEqual({ allele1: '-', allele2: '-' });
      expect(result.data['RS1050450']).toEqual({ allele1: 'C', allele2: 'T' });
    });
  });

  describe('SelfDecode CSV format', () => {
    it('should parse SelfDecode CSV format correctly', () => {
      const content = `rsid,chromosome,position,genotype
rs4880,6,160098096,CC
rs1050450,11,89011046,CT
rs713041,5,132285597,GG`;

      const result = parseGeneticDataString(content);

      expect(result.data['RS4880']).toEqual({ allele1: 'C', allele2: 'C' });
      expect(result.data['RS1050450']).toEqual({ allele1: 'C', allele2: 'T' });
      expect(result.data['RS713041']).toEqual({ allele1: 'G', allele2: 'G' });
    });

    it('should handle CSV with spaces after commas', () => {
      const content = `rsid, chromosome, position, genotype
rs4880, 6, 160098096, CC
rs1050450, 11, 89011046, CT`;

      const result = parseGeneticDataString(content);

      expect(result.data['RS4880']).toEqual({ allele1: 'C', allele2: 'C' });
      expect(result.data['RS1050450']).toEqual({ allele1: 'C', allele2: 'T' });
    });

    it('should parse SelfDecode format with PLINK header and date', () => {
      const content = `# This data file generated by PLINK at: Sun Nov  8 06:10:15 2020
#
# Below is a text version of your data.  Fields are TAB-separated.
# Each line corresponds to a single SNP.  For each SNP, we provide its
# identifier, its location on a reference human genome, and the genotype call.
#
#	rsid	chromosome	position	genotype
rs9701055	1	565433	CC
rs9651229	1	567667	CC
rs11497407	1	568527	GG
rs110402	17	43880047	AA
rs2052129	7	150548972	TT
rs4680	22	19951271	TT`;

      const result = parseGeneticDataString(content);

      expect(result.date).toBe('Nov  8 06:10:15 2020');
      expect(result.data['RS9701055']).toEqual({ allele1: 'C', allele2: 'C' });
      expect(result.data['RS9651229']).toEqual({ allele1: 'C', allele2: 'C' });
      expect(result.data['RS11497407']).toEqual({ allele1: 'G', allele2: 'G' });
      expect(result.data['RS110402']).toEqual({ allele1: 'A', allele2: 'A' });
      expect(result.data['RS2052129']).toEqual({ allele1: 'T', allele2: 'T' });
      expect(result.data['RS4680']).toEqual({ allele1: 'T', allele2: 'T' });
    });

    it('should handle SelfDecode format with complex RS IDs', () => {
      const content = `# This data file generated by PLINK at: Sun Nov  8 06:10:15 2020
#	rsid	chromosome	position	genotype
ilmnseq_rs9701872_ilmndup1,rs9701872	1	568208	TT
GSA-rs116587930	1	727841	--
rs3131972	1	752721	GG`;

      const result = parseGeneticDataString(content);

      // Should skip the complex ID and only parse valid RS IDs
      expect(result.data['RS3131972']).toEqual({ allele1: 'G', allele2: 'G' });
      expect(result.data['RS9701872']).toBeUndefined(); // Complex ID should be skipped
    });
  });

  describe('Edge cases', () => {
    it('should handle empty content', () => {
      const content = '';
      expect(() => parseGeneticDataString(content)).toThrow('Unable to determine file format');
    });

    it('should handle only comments', () => {
      const content = `# Comment 1
# Comment 2
# Comment 3`;
      expect(() => parseGeneticDataString(content)).toThrow('Unable to determine file format');
    });

    it('should normalize RS IDs to uppercase', () => {
      const content = `# rsid chromosome position genotype
rs4880 6 160098096 CC
RS1050450 11 89011046 CT
Rs713041 5 132285597 GG`;

      const result = parseGeneticDataString(content);

      expect(result.data['RS4880']).toBeDefined();
      expect(result.data['RS1050450']).toBeDefined();
      expect(result.data['RS713041']).toBeDefined();
    });

    it('should handle malformed lines gracefully', () => {
      const content = `# rsid chromosome position genotype
rs4880 6 160098096 CC
invalid line here
rs1050450 11 89011046 CT`;

      const result = parseGeneticDataString(content);

      expect(result.data['RS4880']).toEqual({ allele1: 'C', allele2: 'C' });
      expect(result.data['RS1050450']).toEqual({ allele1: 'C', allele2: 'T' });
    });

    it('should handle single character genotypes', () => {
      const content = `# rsid chromosome position genotype
rs4880 6 160098096 C`;

      const result = parseGeneticDataString(content);

      // Single character should be treated as homozygous
      expect(result.data['RS4880']).toEqual({ allele1: 'C', allele2: 'C' });
    });

    it('should handle three character genotypes by taking first two', () => {
      const content = `# rsid chromosome position genotype
rs4880 6 160098096 CCC`;

      const result = parseGeneticDataString(content);

      // Should skip invalid genotypes
      expect(result.data['RS4880']).toBeUndefined();
    });
  });

  describe('Case sensitivity', () => {
    it('should handle lowercase alleles', () => {
      const content = `# rsid chromosome position genotype
rs4880 6 160098096 cc
rs1050450 11 89011046 ct`;

      const result = parseGeneticDataString(content);

      expect(result.data['RS4880']).toEqual({ allele1: 'C', allele2: 'C' });
      expect(result.data['RS1050450']).toEqual({ allele1: 'C', allele2: 'T' });
    });

    it('should handle mixed case alleles', () => {
      const content = `# rsid chromosome position genotype
rs4880 6 160098096 Cc
rs1050450 11 89011046 cT`;

      const result = parseGeneticDataString(content);

      expect(result.data['RS4880']).toEqual({ allele1: 'C', allele2: 'C' });
      expect(result.data['RS1050450']).toEqual({ allele1: 'C', allele2: 'T' });
    });
  });

  describe('Special genotype values', () => {
    it('should handle I and D (insertion/deletion) markers', () => {
      const content = `# rsid chromosome position genotype
rs4880 6 160098096 II
rs1050450 11 89011046 ID
rs713041 5 132285597 DD`;

      const result = parseGeneticDataString(content);

      expect(result.data['RS4880']).toEqual({ allele1: 'I', allele2: 'I' });
      expect(result.data['RS1050450']).toEqual({ allele1: 'I', allele2: 'D' });
      expect(result.data['RS713041']).toEqual({ allele1: 'D', allele2: 'D' });
    });

    it('should handle various missing data formats', () => {
      const content = `# rsid chromosome position genotype
rs4880 6 160098096 --
rs1050450 11 89011046 00`;

      const result = parseGeneticDataString(content);

      expect(result.data['RS4880']).toEqual({ allele1: '-', allele2: '-' });
      // 00 gets normalized to uppercase 0, but should be treated as missing
      expect(result.data['RS1050450']).toBeDefined();
    });
  });
});
